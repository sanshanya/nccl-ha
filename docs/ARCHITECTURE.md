# ARCHITECTURE

# [ARCHITECTURE.md](http://ARCHITECTURE.md) - 架构与设计蓝图

> **文档定位**：本文是项目的架构
> 

---

## 1. 概述与核心目标

nccl-ha 是一个基于 NCCL ext-net 插件接口实现的高可用网络传输层。其核心目标是在不修改 NCCL 核心代码、不牺牲原生性能的前提下，为大规模深度学习训练任务提供网络容错能力。

- **核心目标 1：性能无损 (Peace Time)**：在网络健康状态下，插件的数据路径与原生 NCCL IB 实现的性能和延迟保持一致。
- **核心目标 2：透明容错 (War Time)**：在主网络路径发生瞬时或可恢复的故障时，能自动、透明地切换到预备的"影子备链"，保证上层应用不中断，将致命错误转化为一次可控的网络延迟。
- **核心目标 3：严格合规**：插件的所有实现严格遵守 NCCL ext-net API 的契约和约束。

---

## 2. 核心架构：诚实上报 + 内部智能 + 影子备链

本插件采用一种混合模型，以求在 NCCL 拓扑优化和插件高可用能力之间取得最佳平衡。

### 2.1 诚实上报 (Honest Reporting)

插件将向 NCCL **如实上报**所有可用的物理网络设备及其真实属性。这保证了 NCCL 的全局拓扑求解器可以在信息最完整的情况下，为每个通信 Channel 选择**理论最优的主路径**。

### 2.2 内部智能 (Internal Intelligence)

在 `init()` 阶段，插件将通过解析 sysfs **自行构建**一份内部的、简化的 PCI 拓扑亲和性模型。这个模型不会影响 NCCL 的主路径选择，仅用于插件内部的备链匹配决策。

### 2.3 影子备链 (Shadow Backup Link)

当 NCCL 为某个连接指定了主路径后，插件将利用其内部拓扑模型，为该主路径**智能地、确定性地匹配**一条最佳的"影子备链"，并在后台异步建立和维护它。

### 设计哲学

> **我们不是在构建可靠传输协议，而是在构建 QP 级别的透明故障切换代理。**
> 

> 
> 

> 我们的敌人不是网络丢包（IB RC 硬件已解决），而是链路/端口/NIC 的硬故障。我们把**可靠性交给 RC**，只做**路径容灾切换**。
> 

---

## 3. 高级生命周期设计（精简版）

本节只描述架构原则和设计决策，不包含实现细节和代码。详细的实现指南请参考 [**DEVELOPER_GUIDE**](DEVELOPER_GUIDE%202a2b2c69a6fb805dbd5af22a6cdce3d5.md)。

### 3.1 初始化与设备发现

**设计原则**：

- 如实上报所有物理设备及其真实属性，确保 NCCL 拓扑求解器获得完整信息
- 插件内部通过解析 sysfs 构建 PCI 拓扑亲和性模型，用于后续备链选择
- 可选初始化后台进度线程，用于驱动 CQ 事件和心跳

**资源管理策略**：

- 采用保守的资源配额管理，考虑每个逻辑连接需要 2 个 QP（主备）
- 综合评估 QP、CQ、通道数和并发度，确保不会耗尽硬件资源

### 3.2 连接建立

**设计原则**：

- 采用**两段式非阻塞握手**机制，保证最快的首包发送时间
- 第一阶段：立即返回主 QP 连接参数，严格遵守非阻塞语义
- 第二阶段：主 QP 就绪后，通过已建立的主路径交换备链参数，后台异步建立备用 QP
- 支持**版本协商**和**优雅降级**，兼容不支持 HA 的对端

**契约遵守**：

- `connect/accept` 在未就绪时必须返回 `ncclSuccess + NULL comm`，绝不阻塞
- handle 大小严格 ≤ 128 字节

### 3.3 内存注册

**设计原则**：

- 采用**延迟注册**策略，避免不必要的资源开销
- MR 注册在 Protection Domain (PD) 粒度进行
- 主备链路若在不同 PD，切换时按需注册并缓存复用

### 3.4 数据路径与可靠性机制

**核心设计原则**：

> **将可靠性交给 IB RC 硬件**。RC QP 已提供可靠、有序的端到端传输。插件层只负责在链路/端口级故障时的路径切换与 Work Request (WR) 重放。
> 

**分层交互策略**：

- **硬件层（第一道防线）**：配置适当的硬件超时和重试参数，让硬件首先尝试自愈
- **插件层（最后手段）**：软超时阈值必须显著大于硬件重传周期（通常 ≥ 2 倍），确保只在硬件放弃后才触发切换

**数据流策略**：

- 和平时期所有数据流量**严格只走主 QP**
- 备用 QP 只用于低频心跳和健康检查
- 故障切换时采用保守的触发条件，避免误切换

**请求跟踪与重放**：

- 保存所有 inflight 请求的完整信息，用于故障时重放
- 采用原子切换机制，确保并发场景下的正确性
- 切换过程：主 QP 置为 ERR → flush SQ → 切换活跃 QP → 延迟 MR 注册 → 重放未完成的 WR

---

## 4. 错误处理层次

插件将明确区分并处理三类错误：

| 错误类型 | 判断依据 | 处理策略 |
| --- | --- | --- |
| **瞬时错误** | CQ 返回 `IBV_WC_WR_FLUSH_ERR` | 正常现象（上游关闭引起的连带 flush），忽略或作为降噪 |
| **可恢复错误** | 软超时触发，或主 QP 返回 `IBV_WC_RETRY_EXC_ERR` 等路径错误，且备链心跳健康 | 触发向备链的切换和 WR 重放 |
| **致命错误** | 主备链均无法通信，或达到最大重试次数 | 停止重试，向上返回 `ncclSystemError` |

**错误检测与 verbs 语义对齐**：

- `IBV_WC_RETRY_EXC_ERR`：硬件重试耗尽，进入可恢复错误流程
- `IBV_WC_RNR_RETRY_EXC_ERR`：接收方未就绪重试耗尽
- `IBV_WC_REM_ACCESS_ERR`：远端访问错误，可能是链路故障

**备链健康判断**：

- 连续收到 N 次（如 3 次）心跳 PONG → 健康
- 超过阈值时间（如 3 × HEARTBEAT_MS）未收到 PONG → 不健康

---

## 5. 已知限制与兼容性

- **资源开销**：增加了备用 QP/CQ 的资源占用（已通过 maxComms 配额管理）
- **内存注册开销**：故障切换时，会产生一次性的、延迟的 MR 注册开销（通常 <10ms）
- **WR 重放开销**：切换时需要重新投递所有 inflight 的 WR，可能导致短暂的延迟尖峰
- **Symmetric Memory 兼容性**：当前设计主要针对**跨节点网络路径**。对于节点内通信，NCCL 可能会优先使用其内部的 P2P/NVLink 机制（绕过网络插件），因此本插件的 HA 能力主要体现在跨节点场景

---

## 6. 可观测性与配置

插件提供一套以 `HA_NCCL_` 为前缀的环境变量，用于控制和调试：

- `HA_NCCL_ENABLE_BACKUP=1`：是否启用高可用模式（默认: 1）
- `HA_NCCL_HEARTBEAT_MS=200`：心跳探测间隔（毫秒）
- `HA_NCCL_RTO_MS=1000`：重传超时时间（毫秒，必须 > 硬件重传窗口 × 2）
- `HA_NCCL_MAX_RETRIES=10`：最大重传次数
- `HA_NCCL_ENABLE_FAILBACK=0`：是否在主路恢复后自动切回
- `HA_NCCL_DEBUG=0`：调试日志级别（0-3）
- `HA_NCCL_USE_PROGRESS_THREAD=1`：是否使用后台进度线程（默认: 1）

---

## 8. 非目标 (Scope Definition)

为明确插件的适用边界，本项目不试图解决以下问题：

- ❌ **节点内故障切换**：由 NCCL 自身的 P2P/NVLink 机制负责
- ❌ **运行时动态拓扑变化**：不支持运行时热插拔网卡
- ❌ **与特定高级 RDMA 功能的组合**：如 GPUDirect Async 等
- ❌ **实时性保证**：本插件适用于吞吐量敏感的训练任务，不保证微秒级的故障切换，不适用于对实时性有极高要求的推理服务
- ❌ **软件层可靠传输**：不实现 TCP 式的 SEQ/ACK 机制，完全依赖 IB RC 硬件保证

---

## 10. 附录 A：HA 与 makeVDevice 的取舍

| 维度 | 插件内主备 (本方案) | vNIC 融合 (makeVDevice) |
| --- | --- | --- |
| **透明性** | 对 NCCL 完全透明 | NCCL 感知到"一块虚拟 NIC" |
| **带宽聚合** | 仅故障时使用备链，无聚合 | 可实现多链路聚合带宽 |
| **实现复杂度** | 中等（状态机+切换逻辑） | 高（需实现调度器+负载均衡） |
| **适用场景** | 容错为主要目标 | 带宽聚合为主要目标 |
| **资源利用率** | 低（备链平时空闲） | 高（所有链路同时工作） |
| **故障影响** | 透明切换，延迟增加 | 带宽降级，但可继续工作 |

**推荐策略**：

- 若目标是**高可用容错**，使用本方案（插件内主备）
- 若目标是**带宽聚合**，考虑实现 makeVDevice
- 两者可以结合：为每个 vNIC 内部实现主备

---

## 14. 设计迭代记录

- **v1.0**：初始设计，包含完整的 SEQ/ACK 机制
- **v2.0**：补充非阻塞建链、MR 字段申报等细节
- **v3.0**：强化顺序匹配约束、后台线程架构
- **v4.0**：**简化设计，移除 SEQ/ACK 机制**，改为依赖 IB RC 硬件可靠性，专注于路径切换与 WR 重放。新增完整的早期验证路线图
- **v4.1**：**收紧技术约束**，澄清 Recv WR 重放的分组语义、OPTIONAL_RECV_COMPLETION 使用场景、maxRecvs 与资源预算的关系，以及进度线程的轮询策略

## 14. 设计迭代记录

- **v1.0**：初始设计，包含完整的 SEQ/ACK 机制
- **v2.0**：补充非阻塞建链、MR 字段申报等细节
- **v3.0**：强化顺序匹配约束、后台线程架构
- **v4.0**：**简化设计，移除 SEQ/ACK 机制**，改为依赖 IB RC 硬件可靠性，专注于路径切换与 WR 重放。新增完整的早期验证路线图
- **v4.1**：**收紧技术约束**，澄清 Recv WR 重放的分组语义、OPTIONAL_RECV_COMPLETION 使用场景、maxRecvs 与资源预算的关系，以及进度线程的轮询策略
- **v4.2**：**可实现化修订**，明确复用 nccl-rdma-sharp-plugins 的策略，调整 QP 超时参数以支撑秒级切换，补充外部实现参考与未来演进路线

---

## 15. 外部实现参考与未来演进

### 15.1 UCCL：软件可扩展传输层

**技术特点**：

- 将可靠性/拥塞规避/多路径策略上移到软件层
- 采用 packet spraying（包喷洒）与 Selective Repeat（选择性重传）
- 支持最多 256 条路径并行，实现带宽聚合
- 与 NCCL/RCCL API 完全兼容

**与本项目的区别**：

- UCCL：在软件层自己做可靠/重传/调度
- nccl-ha：将可靠性交给 RC 硬件，仅做 QP 级透明切换

**对本项目的启示**：

1. **当前阶段（一个月冲刺）**：保持"RC 可靠，插件只做 failover"的范围
2. **预埋扩展点**：
    - 心跳与健康度不仅看"是否通"，还要抽样 RTT/完成时间分布（轻量指标）
    - 为后续"劣化→切换"的判据留钩子
    - 影子链路接口与状态机设计为可扩展到多备链（不是立刻做带宽聚合，仅做多备份/多候选）

### 15.2 nccl-rdma-sharp-plugins：IB 插件的"黄金样板"

**可直接复用的模块**：

- **非阻塞握手状态机**：通过自管 socket 与分段发送的 handle 元数据完成握手
- **设备虚拟化与多 QP**：vProps/ndevs/qps 结构，makeVDevice 聚合多物理 NIC
- **GID/ROCE/IB 参数选择**：GID index 选择、RoCE v1/v2 判断、SL/TC/AR/ECE 处理
- **MR 缓存与 DMA-BUF**：per-device MR cache、DMA-BUF 注册分支
- **完成事件与错误处理**：test() 里的事件计数与 ibv_wc_status 分类
- **接口兼容多版本**：v6–v11 的导出表设计

**复用策略**：

- 直接裁剪其握手、设备抽象、QP/verbs 封装、MR cache/DMA-BUF、CQ/错误语义
- 在其数据通路与完成轮询上加一层 HA 切换逻辑
- 保留 BSD-3 版权头，遵守开源协议

---

## 16. 关键参数的设计理由

### 16.1 QP 超时参数的取舍

| 参数 | 官方 IB 插件默认值 | nccl-ha 建议值 | 设计理由 |
| --- | --- | --- | --- |
| `IB_TIMEOUT` | 20（≈4.1s） | **14**（≈67ms） | 缩短硬件重试窗口到 ~0.47s，支撑秒级切换 |
| `IB_RETRY_CNT` | 7 | 7 | 保持与官方一致的重试次数 |
| `HA_NCCL_RTO_MS` | - | 1000–1500 | 软超时 > 硬件周期 × 2，避免与硬件重试冲突 |

**权衡说明**：

- 官方默认值（timeout=20）会导致硬件总重传周期 ≈ 28s，使 failover 拖到 30 秒级
- 我们**刻意**与官方不同，是为了实现秒级切换的用户体验
- 提供 `HA_NCCL_FORCE_IB_TIMEOUT` 环境变量，避免被发行版 OFED/NCCL 全局环境变量覆盖

**误切换风险缓解**：

- 通过"软 RTO > 硬件总周期 × 2"确保只在硬件放弃后才触发
- 以 `IBV_WC_RETRY_EXC_ERR` 作为硬触发条件
- 备链健康检查机制（连续 3 次心跳失败才判定不健康）

### 16.2 资源配额的保守策略

**maxComms 计算考虑**：

- 每逻辑连接需要 2 个 QP（主备）
- Send 侧 CQE 需求 = expected_wr_per_conn × maxRecvs（因为 grouped receive）
- Recv 侧 CQE 需求 = expected_wr_per_conn
- 按最紧张的资源维度（QP 或 CQE）计算，并留安全余量

---

## 交叉引用

- **实现细节和代码**：参见 [**DEVELOPER_GUIDE**](DEVELOPER_GUIDE%202a2b2c69a6fb805dbd5af22a6cdce3d5.md)
- **验证与测试**：参见 [**VALIDATION_PLAN**](VALIDATION_PLAN%202a2b2c69a6fb80c3bf4ac51103940c4e.md)

## 附录 B：关键架构决策与备选方案评估

本文档记录了 nccl-ha 插件在技术选型阶段的关键决策过程。为确保项目路径的清晰与专注，我们评估了多种备选方案，并在此阐明选择当前路线的核心理由。

### 决策 1：选择“完全实现”而非“扩展原生插件”

- **备选方案**：继承或组合 NCCL 原生的 `ib` 插件，仅修改部分功能。
- **评估**：此方案在技术上不可行。NCCL 原生 `ib` 插件是闭源的，我们无法获取其源代码。更重要的是，NCCL 插件接口是一种“提供者模式”而非“继承模式”。插件必须提供一套完整的、状态自洽的函数实现，因为连接 (`comm`) 和内存 (`mhandle`) 句柄的状态在不同实现间不兼容。
- **最终决策**：**从零开始，使用 `libibverbs` 完整实现 NCCL Net API**。这是唯一能确保我们完全掌控插件行为，并能注入高可用逻辑的路径。

### 决策 2：选择“从基础构建”而非“基于 SHARP 插件”

- **备选方案**：基于 `Mellanox/nccl-rdma-sharp-plugins` 进行二次开发，因为它性能最接近原生插件。
- **评估**：`nccl-rdma-sharp-plugins` 是一个为了“硬件卸载 (SHARP)”这一**特定目标**而高度优化的复杂项目，好比一辆“F1 赛车”。我们的目标是“高可用性”，好比一辆“装甲越野车”。基于 F1 赛车去改装越野车，意味着 90% 的工作将是拆解和对抗我们不需要的复杂系统（如 SHARP 调度逻辑），而非构建我们需要的核心功能。
- **最终决策**：**将 `nccl-rdma-sharp-plugins` 作为一个高级的“参考学习对象”，而非“项目模板”**。我们的代码基础应从最简单、最通用的 `libibverbs` 示例 (`rc_pingpong.c`) 开始，确保代码库的简洁、专注和 100% 可控。

### 决策 3：选择“服务 NCCL”而非“拥抱 UCCL”

- **备选方案**：考虑到从零实现的复杂性，转而基于更现代的 UCCL (`uccl-project/uccl`) 框架构建。
- **评估**：这是一个软件栈层次的混淆。UCCL 是与 NCCL 平级的“集合通信库”（第 3 层），而我们的项目是为 NCCL 服务的“网络传输插件”（第 2 层）。选择 UCCL 意味着完全改变项目目标，放弃服务当前庞大的 NCCL 生态系统。
- **最终决策**：**严格遵守项目使命，作为 NCCL 生态的一部分，为其提供网络高可用能力。** 我们的价值在于解决现有 NCCL 用户的痛点。

### 决策 4：选择“v8 API 起步”而非“从 v6 渐进”

- **备选方案**：从 API 函数最少的 `v6` 版本开始，实现 MVP，未来再按需升级到 `v7/v8`。
- **评估**：该策略在通用场景下非常稳健。但在本项目中，我们拥有**一份明确基于 v8 API 编写的详细设计文档 (`DEVELOPER_GUIDE.md`)**。
    1. **遵循蓝图**：与项目自身的“圣经”保持一致是降低内部混乱风险的最高优先级。
    2. **成本极低**：实现一个最小化的 v8 插件，相比 v6 的额外工作量几乎为零（多填几个 `NULL` 和默认值）。
    3. **避免重构**：直接从 v8 开始，可以确保我们的架构设计从第一天起就是为了最终形态服务的，避免了未来因 API 不匹配而进行的破坏性重构。
- **最终决策**：**直接采用 v8 API 作为开发基线，但以 MVP (最小可行产品) 的精神去实现它**。对于 v8 新增的、暂时不需要的函数，在宏中填 `NULL`；对于新增的属性字段，填上安全的默认值。这完美结合了架构的正确性和开发的敏捷性。